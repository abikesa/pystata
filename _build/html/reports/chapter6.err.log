Traceback (most recent call last):
  File "/Users/apollo/Documents/Melody/myenv/lib/python3.12/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/Users/apollo/Documents/Melody/myenv/lib/python3.12/site-packages/nbclient/client.py", line 1314, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/apollo/Documents/Melody/myenv/lib/python3.12/site-packages/jupyter_core/utils/__init__.py", line 165, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py", line 687, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/Users/apollo/Documents/Melody/myenv/lib/python3.12/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/Users/apollo/Documents/Melody/myenv/lib/python3.12/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/Users/apollo/Documents/Melody/myenv/lib/python3.12/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import pandas as pd
from lifelines import KaplanMeierFitter
import matplotlib.pyplot as plt

# Assuming 'data' is already the DataFrame loaded previously

# Set the event indicator based on 'Died'
data['event'] = (data['rSMGJcEdF_d'] == 'Died').astype(int)

# Ensure date columns are in datetime format
data['rSMGJcEdF_tT'] = pd.to_datetime(data['rSMGJcEdF_tT'], errors='coerce')
data['rSMGJcEdF_t0'] = pd.to_datetime(data['rSMGJcEdF_t0'], errors='coerce')
data['entry'] = data['rSMGJcEdF_t0']  # Use _t0 as entry

# Calculate the duration from origin to the event or censoring in years
data['duration'] = (data['rSMGJcEdF_tT'] - data['rSMGJcEdF_t0']).dt.total_seconds() / (365.25 * 24 * 60 * 60)

# Calculate the entry duration
data['entry_duration'] = (data['entry'] - data['rSMGJcEdF_t0']).dt.total_seconds() / (365.25 * 24 * 60 * 60)
data['entry_duration'] = data['entry_duration'].fillna(0)  # Ensure non-donor entries are set to 0

# Ensure all durations are non-negative and valid
data = data[(data['duration'] >= 0) & (data['entry_duration'] >= 0)]

# Initialize the KaplanMeierFitter
kmf = KaplanMeierFitter()

# Plot setup
plt.figure(figsize=(10, 6))

# Unique donor values
donor_values = data['donor'].unique()

# Colors for each donor type
colors = ['blue', 'green', 'red']

# Overlay plots for different donor values
for donor, color in zip(donor_values, colors):
    kmf.fit(durations=data[data['donor'] == donor]['duration'],
            event_observed=data[data['donor'] == donor]['event'],
            entry=data[data['donor'] == donor]['entry_duration'],
            label=donor)
    ax = kmf.plot_cumulative_density(ci_show=False, color=color)

# Cut off the plot at 15 years
plt.xlim(0, 15)

# Convert y-axis to percentage
vals = ax.get_yticks()
ax.set_yticklabels(['{:,.0%}'.format(x) for x in vals])

# Labels and title
plt.xlabel("Time (years)")
plt.ylabel("Failure Probability (%)")
plt.title("Failure Function Plot (Cumulative Density) by Donor Type")
plt.legend(title="Donor Type")

# Optional: Display the plot (depends on your environment)
plt.show()

------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mTypeError[0m                                 Traceback (most recent call last)
Cell [0;32mIn[4], line 8[0m
[1;32m      3[0m [38;5;28;01mimport[39;00m [38;5;21;01mmatplotlib[39;00m[38;5;21;01m.[39;00m[38;5;21;01mpyplot[39;00m [38;5;28;01mas[39;00m [38;5;21;01mplt[39;00m
[1;32m      5[0m [38;5;66;03m# Assuming 'data' is already the DataFrame loaded previously[39;00m
[1;32m      6[0m 
[1;32m      7[0m [38;5;66;03m# Set the event indicator based on 'Died'[39;00m
[0;32m----> 8[0m data[[38;5;124m'[39m[38;5;124mevent[39m[38;5;124m'[39m] [38;5;241m=[39m ([43mdata[49m[43m[[49m[38;5;124;43m'[39;49m[38;5;124;43mrSMGJcEdF_d[39;49m[38;5;124;43m'[39;49m[43m][49m [38;5;241m==[39m [38;5;124m'[39m[38;5;124mDied[39m[38;5;124m'[39m)[38;5;241m.[39mastype([38;5;28mint[39m)
[1;32m     10[0m [38;5;66;03m# Ensure date columns are in datetime format[39;00m
[1;32m     11[0m data[[38;5;124m'[39m[38;5;124mrSMGJcEdF_tT[39m[38;5;124m'[39m] [38;5;241m=[39m pd[38;5;241m.[39mto_datetime(data[[38;5;124m'[39m[38;5;124mrSMGJcEdF_tT[39m[38;5;124m'[39m], errors[38;5;241m=[39m[38;5;124m'[39m[38;5;124mcoerce[39m[38;5;124m'[39m)

[0;31mTypeError[0m: 'NoneType' object is not subscriptable

